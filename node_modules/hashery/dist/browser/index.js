var _=Object.defineProperty;var S=(u,r,e)=>r in u?_(u,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):u[r]=e;var f=(u,r,e)=>S(u,typeof r!="symbol"?r+"":r,e);import{Hookified as x}from"hookified";var y=class{get name(){return"crc32"}toHashSync(r){let e;if(r instanceof Uint8Array)e=r;else if(r instanceof ArrayBuffer)e=new Uint8Array(r);else if(r instanceof DataView)e=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);else{let h=r;e=new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}let s=3988292384,t=4294967295;for(let h=0;h<e.length;h++){t=t^e[h];for(let i=0;i<8;i++)t=t>>>1^s&-(t&1)}return t=(t^4294967295)>>>0,t.toString(16).padStart(8,"0")}async toHash(r){return this.toHashSync(r)}};var p=class{constructor(r){f(this,"_algorithm","SHA-256");r?.algorithm&&(this._algorithm=r?.algorithm)}get name(){return this._algorithm}async toHash(r){let e=await crypto.subtle.digest(this._algorithm,r);return Array.from(new Uint8Array(e)).map(n=>n.toString(16).padStart(2,"0")).join("")}};var d=class{get name(){return"djb2"}toHashSync(r){let e;if(r instanceof Uint8Array)e=r;else if(r instanceof ArrayBuffer)e=new Uint8Array(r);else if(r instanceof DataView)e=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);else{let n=r;e=new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}let s=5381;for(let n=0;n<e.length;n++)s=(s<<5)+s+e[n],s=s>>>0;return s.toString(16).padStart(8,"0")}async toHash(r){return this.toHashSync(r)}};var b=class{get name(){return"fnv1"}toHashSync(r){let e;if(r instanceof Uint8Array)e=r;else if(r instanceof ArrayBuffer)e=new Uint8Array(r);else if(r instanceof DataView)e=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);else{let i=r;e=new Uint8Array(i.buffer,i.byteOffset,i.byteLength)}let s=2166136261,t=16777619,n=s;for(let i=0;i<e.length;i++)n=n*t,n=n^e[i],n=n>>>0;return n.toString(16).padStart(8,"0")}async toHash(r){return this.toHashSync(r)}};var H=class{constructor(r=0){f(this,"_seed");this._seed=r>>>0}get name(){return"murmer"}get seed(){return this._seed}toHashSync(r){let e;if(r instanceof Uint8Array)e=r;else if(r instanceof ArrayBuffer)e=new Uint8Array(r);else if(r instanceof DataView)e=new Uint8Array(r.buffer,r.byteOffset,r.byteLength);else{let c=r;e=new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}let s=3432918353,t=461845907,n=e.length,h=Math.floor(n/4),i=this._seed;for(let c=0;c<h;c++){let m=c*4,g=e[m]&255|(e[m+1]&255)<<8|(e[m+2]&255)<<16|(e[m+3]&255)<<24;g=this._imul(g,s),g=this._rotl32(g,15),g=this._imul(g,t),i^=g,i=this._rotl32(i,13),i=this._imul(i,5)+3864292196}let a=h*4,o=0;switch(n&3){case 3:o^=(e[a+2]&255)<<16;case 2:o^=(e[a+1]&255)<<8;case 1:o^=e[a]&255,o=this._imul(o,s),o=this._rotl32(o,15),o=this._imul(o,t),i^=o}return i^=n,i^=i>>>16,i=this._imul(i,2246822507),i^=i>>>13,i=this._imul(i,3266489909),i^=i>>>16,i=i>>>0,i.toString(16).padStart(8,"0")}async toHash(r){return this.toHashSync(r)}_imul(r,e){if(Math.imul)return Math.imul(r,e);let s=r>>>16&65535;let t=r&65535;let n=e>>>16&65535;let h=e&65535;return t*h+(s*h+t*n<<16>>>0)|0}_rotl32(r,e){return r<<e|r>>>32-e}};var v=class{constructor(r){f(this,"_providers",new Map);f(this,"_getFuzzy",!0);r?.providers&&this.loadProviders(r?.providers),r?.getFuzzy!==void 0&&(this._getFuzzy=!!r?.getFuzzy)}loadProviders(r){for(let e of r)this._providers.set(e.name,e)}get providers(){return this._providers}set providers(r){this._providers=r}get names(){return Array.from(this._providers.keys())}get(r,e){let s=e?.fuzzy??this._getFuzzy;r=r.trim();let t=this._providers.get(r);return t===void 0&&s===!0&&(r=r.toLowerCase(),t=this._providers.get(r)),t===void 0&&s===!0&&(r=r.replaceAll("-",""),t=this._providers.get(r)),t}add(r){this._providers.set(r.name,r)}remove(r){return this._providers.delete(r)}};var A=class extends x{constructor(e){super(e);f(this,"_parse",JSON.parse);f(this,"_stringify",JSON.stringify);f(this,"_providers",new v);f(this,"_defaultAlgorithm","SHA-256");f(this,"_defaultAlgorithmSync","djb2");e?.parse&&(this._parse=e.parse),e?.stringify&&(this._stringify=e.stringify),e?.defaultAlgorithm&&(this._defaultAlgorithm=e.defaultAlgorithm),e?.defaultAlgorithmSync&&(this._defaultAlgorithmSync=e.defaultAlgorithmSync),this.loadProviders(e?.providers,{includeBase:e?.includeBase??!0})}get parse(){return this._parse}set parse(e){this._parse=e}get stringify(){return this._stringify}set stringify(e){this._stringify=e}get providers(){return this._providers}set providers(e){this._providers=e}get names(){return this._providers.names}get defaultAlgorithm(){return this._defaultAlgorithm}set defaultAlgorithm(e){this._defaultAlgorithm=e}get defaultAlgorithmSync(){return this._defaultAlgorithmSync}set defaultAlgorithmSync(e){this._defaultAlgorithmSync=e}async toHash(e,s){let t={data:e,algorithm:s?.algorithm??this._defaultAlgorithm,maxLength:s?.maxLength};await this.beforeHook("toHash",t);let n=this._stringify(t.data),i=new TextEncoder().encode(n),a=this._providers.get(t.algorithm);a||(a=new p({algorithm:this._defaultAlgorithm}));let o=await a.toHash(i);s?.maxLength&&o.length>s?.maxLength&&(o=o.substring(0,s.maxLength));let l={hash:o,data:t.data,algorithm:t.algorithm};return await this.afterHook("toHash",l),l.hash}async toNumber(e,s={}){let{min:t=0,max:n=100,algorithm:h=this._defaultAlgorithm,hashLength:i=16}=s;if(t>n)throw new Error("min cannot be greater than max");let a=await this.toHash(e,{algorithm:h,maxLength:i}),o=Number.parseInt(a,16),l=n-t+1;return t+o%l}toHashSync(e,s){let t={data:e,algorithm:s?.algorithm??this._defaultAlgorithmSync,maxLength:s?.maxLength};this.beforeHook("toHashSync",t);let n=t.algorithm,h=this._stringify(t.data),a=new TextEncoder().encode(h),o=this._providers.get(n);if(!o)throw new Error(`Hash provider '${n}' not found`);if(!o.toHashSync)throw new Error(`Hash provider '${n}' does not support synchronous hashing. Use toHash() instead or choose a different algorithm (djb2, fnv1, murmer, crc32).`);let l=o.toHashSync(a);s?.maxLength&&l.length>s?.maxLength&&(l=l.substring(0,s.maxLength));let c={hash:l,data:t.data,algorithm:t.algorithm};return this.afterHook("toHashSync",c),c.hash}toNumberSync(e,s={}){let{min:t=0,max:n=100,algorithm:h=this._defaultAlgorithmSync,hashLength:i=16}=s;if(t>n)throw new Error("min cannot be greater than max");let a=this.toHashSync(e,{algorithm:h,maxLength:i}),o=Number.parseInt(a,16),l=n-t+1;return t+o%l}loadProviders(e,s={includeBase:!0}){if(e)for(let t of e)this._providers.add(t);s.includeBase&&(this.providers.add(new p({algorithm:"SHA-256"})),this.providers.add(new p({algorithm:"SHA-384"})),this.providers.add(new p({algorithm:"SHA-512"})),this.providers.add(new y),this.providers.add(new d),this.providers.add(new b),this.providers.add(new H))}};export{A as Hashery};
/* v8 ignore next -- @preserve */
//# sourceMappingURL=index.js.map