// SPDX-FileCopyrightText: 2024 LiveKit, Inc.
//
// SPDX-License-Identifier: Apache-2.0
import { create } from '@bufbuild/protobuf';
import { Mutex } from '@livekit/mutex';
import { AudioFrame } from './audio_frame.js';
import { FfiClient, FfiClientEvent, FfiHandle } from './ffi_client.js';
import { AudioStreamType, NewAudioStreamRequestSchema } from './proto/audio_frame_pb.js';
export class AudioStream {
    constructor(track, sampleRate = 48000, numChannels = 1) {
        /** @internal */
        this.eventQueue = [];
        /** @internal */
        this.queueResolve = null;
        /** @internal */
        this.mutex = new Mutex();
        this.onEvent = (ev) => {
            if (ev.message.case != 'audioStreamEvent' ||
                ev.message.value.streamHandle != this.ffiHandle.handle) {
                return;
            }
            const streamEvent = ev.message.value.message;
            switch (streamEvent.case) {
                case 'frameReceived':
                    const frame = AudioFrame.fromOwnedInfo(streamEvent.value.frame);
                    if (this.queueResolve) {
                        this.queueResolve({ done: false, value: frame });
                    }
                    else {
                        this.eventQueue.push(frame);
                    }
                    break;
                case 'eos':
                    FfiClient.instance.off(FfiClientEvent.FfiEvent, this.onEvent);
                    break;
            }
        };
        this.track = track;
        this.sampleRate = sampleRate;
        this.numChannels = numChannels;
        const req = create(NewAudioStreamRequestSchema, {
            type: AudioStreamType.AUDIO_STREAM_NATIVE,
            trackHandle: track.ffi_handle.handle,
            sampleRate: sampleRate,
            numChannels: numChannels,
        });
        const res = FfiClient.instance.request({
            message: {
                case: 'newAudioStream',
                value: req,
            },
        });
        this.info = res.stream.info;
        this.ffiHandle = new FfiHandle(res.stream.handle.id);
        FfiClient.instance.on(FfiClientEvent.FfiEvent, this.onEvent);
    }
    async next() {
        const unlock = await this.mutex.lock();
        if (this.eventQueue.length > 0) {
            unlock();
            const value = this.eventQueue.shift();
            if (value) {
                return { done: false, value };
            }
            else {
                return { done: true, value: undefined };
            }
        }
        const promise = new Promise((resolve) => (this.queueResolve = resolve));
        unlock();
        return promise;
    }
    close() {
        this.eventQueue.push(null);
        this.ffiHandle.dispose();
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
//# sourceMappingURL=audio_stream.js.map