// SPDX-FileCopyrightText: 2024 LiveKit, Inc.
//
// SPDX-License-Identifier: Apache-2.0
import { create } from '@bufbuild/protobuf';
import { FfiClient, FfiHandle } from './ffi_client.js';
import { ChatMessageSchema, EditChatMessageRequestSchema, PublishDataRequestSchema, PublishSipDtmfRequestSchema, PublishTrackRequestSchema, PublishTranscriptionRequestSchema, SendChatMessageRequestSchema, SetLocalAttributesRequestSchema, SetLocalMetadataRequestSchema, SetLocalNameRequestSchema, UnpublishTrackRequestSchema, } from './proto/room_pb.js';
import { TranscriptionSegmentSchema } from './proto/room_pb.js';
import { PerformRpcRequestSchema, RegisterRpcMethodRequestSchema, RpcMethodInvocationResponseRequestSchema, UnregisterRpcMethodRequestSchema, } from './proto/rpc_pb.js';
import { RpcError } from './rpc.js';
import { LocalTrackPublication } from './track_publication.js';
export class Participant {
    constructor(owned_info) {
        this.trackPublications = new Map();
        this.info = owned_info.info;
        this.ffi_handle = new FfiHandle(owned_info.handle.id);
    }
    get sid() {
        return this.info.sid;
    }
    get name() {
        return this.info.name;
    }
    get identity() {
        return this.info.identity;
    }
    get metadata() {
        return this.info.metadata;
    }
    get attributes() {
        return this.info.attributes;
    }
    get kind() {
        return this.info.kind;
    }
}
export class LocalParticipant extends Participant {
    constructor() {
        super(...arguments);
        this.rpcHandlers = new Map();
        this.trackPublications = new Map();
    }
    async publishData(data, options) {
        const req = create(PublishDataRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            dataPtr: FfiClient.instance.retrievePtr(data),
            dataLen: BigInt(data.byteLength),
            reliable: options.reliable,
            topic: options.topic,
            destinationIdentities: options.destination_identities,
        });
        const res = FfiClient.instance.request({
            message: { case: 'publishData', value: req },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'publishData' && ev.message.value.asyncId == res.asyncId;
        });
        if (cb.error) {
            throw new Error(cb.error);
        }
    }
    async publishDtmf(code, digit) {
        const req = create(PublishSipDtmfRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            code,
            digit,
        });
        const res = FfiClient.instance.request({
            message: { case: 'publishSipDtmf', value: req },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'publishSipDtmf' && ev.message.value.asyncId == res.asyncId;
        });
        if (cb.error) {
            throw new Error(cb.error);
        }
    }
    async publishTranscription(transcription) {
        const req = create(PublishTranscriptionRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            participantIdentity: transcription.participantIdentity,
            segments: transcription.segments.map((s) => create(TranscriptionSegmentSchema, {
                id: s.id,
                text: s.text,
                startTime: s.startTime,
                endTime: s.endTime,
                final: s.final,
                language: s.language,
            })),
            trackId: transcription.trackSid,
        });
        const res = FfiClient.instance.request({
            message: { case: 'publishTranscription', value: req },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'publishTranscription' && ev.message.value.asyncId == res.asyncId;
        });
        if (cb.error) {
            throw new Error(cb.error);
        }
    }
    async updateMetadata(metadata) {
        const req = create(SetLocalMetadataRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            metadata: metadata,
        });
        const res = FfiClient.instance.request({
            message: { case: 'setLocalMetadata', value: req },
        });
        await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'setLocalMetadata' && ev.message.value.asyncId == res.asyncId;
        });
    }
    /**
     * Sends a chat message to participants in the room
     *
     * @param text - The text content of the chat message.
     * @param destinationIdentities - An optional array of recipient identities to whom the message will be sent. If omitted, the message is broadcast to all participants.
     * @param senderIdentity - An optional identity of the sender. If omitted, the default sender identity is used.
     *
     */
    async sendChatMessage(text, destinationIdentities, senderIdentity) {
        const req = create(SendChatMessageRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            message: text,
            destinationIdentities,
            senderIdentity,
        });
        const res = FfiClient.instance.request({
            message: { case: 'sendChatMessage', value: req },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'chatMessage' && ev.message.value.asyncId == res.asyncId;
        });
        if (cb.message.case !== 'chatMessage') {
            throw new Error(cb.message.value ?? 'Unknown Error');
        }
        const { id, timestamp, editTimestamp, message } = cb.message.value;
        return { id, timestamp: Number(timestamp), editTimestamp: Number(editTimestamp), message };
    }
    /**
     * @experimental
     */
    async editChatMessage(editText, originalMessage, destinationIdentities, senderIdentity) {
        const req = create(EditChatMessageRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            editText,
            originalMessage: create(ChatMessageSchema, {
                ...originalMessage,
                timestamp: BigInt(originalMessage.timestamp),
                editTimestamp: originalMessage.editTimestamp
                    ? BigInt(originalMessage.editTimestamp)
                    : undefined,
            }),
            destinationIdentities,
            senderIdentity,
        });
        const res = FfiClient.instance.request({
            message: { case: 'editChatMessage', value: req },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'chatMessage' && ev.message.value.asyncId == res.asyncId;
        });
        if (cb.message.case !== 'chatMessage') {
            throw new Error(cb.message.value ?? 'Unknown Error');
        }
        const { id, timestamp, editTimestamp, message } = cb.message.value;
        return { id, timestamp: Number(timestamp), editTimestamp: Number(editTimestamp), message };
    }
    async updateName(name) {
        const req = create(SetLocalNameRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            name: name,
        });
        const res = FfiClient.instance.request({
            message: { case: 'setLocalName', value: req },
        });
        await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'setLocalName' && ev.message.value.asyncId == res.asyncId;
        });
    }
    async setAttributes(attributes) {
        const req = create(SetLocalAttributesRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            attributes: Array.from(Object.entries(attributes)).map(([key, value]) => {
                return { key, value };
            }),
        });
        const res = FfiClient.instance.request({
            message: { case: 'setLocalAttributes', value: req },
        });
        await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'setLocalAttributes' && ev.message.value.asyncId == res.asyncId;
        });
    }
    async publishTrack(track, options) {
        const req = create(PublishTrackRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            trackHandle: track.ffi_handle.handle,
            options: options,
        });
        const res = FfiClient.instance.request({
            message: { case: 'publishTrack', value: req },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'publishTrack' && ev.message.value.asyncId == res.asyncId;
        });
        if (cb.message.case !== 'publication') {
            throw new Error(cb.message.value ?? 'Unknown Error');
        }
        const track_publication = new LocalTrackPublication(cb.message.value);
        track_publication.track = track;
        this.trackPublications.set(track_publication.sid, track_publication);
        return track_publication;
    }
    async unpublishTrack(trackSid) {
        const req = create(UnpublishTrackRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            trackSid: trackSid,
        });
        const res = FfiClient.instance.request({
            message: { case: 'unpublishTrack', value: req },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'unpublishTrack' && ev.message.value.asyncId == res.asyncId;
        });
        if (cb.error) {
            throw new Error(cb.error);
        }
        const pub = this.trackPublications.get(trackSid);
        if (pub) {
            pub.track = undefined;
        }
        this.trackPublications.delete(trackSid);
    }
    /**
     * Initiate an RPC call to a remote participant.
     * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}
     * @returns A promise that resolves with the response payload or rejects with an error.
     * @throws Error on failure. Details in `message`.
     */
    async performRpc({ destinationIdentity, method, payload, responseTimeout, }) {
        const req = create(PerformRpcRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            destinationIdentity,
            method,
            payload,
            responseTimeoutMs: responseTimeout,
        });
        const res = FfiClient.instance.request({
            message: { case: 'performRpc', value: req },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case === 'performRpc' && ev.message.value.asyncId === res.asyncId;
        });
        if (cb.error) {
            throw RpcError.fromProto(cb.error);
        }
        return cb.payload;
    }
    /**
     * Establishes the participant as a receiver for calls of the specified RPC method.
     * Will overwrite any existing callback for the same method.
     *
     * @param method - The name of the indicated RPC method
     * @param handler - Will be invoked when an RPC request for this method is received
     * @returns A promise that resolves when the method is successfully registered
     *
     * @example
     * ```typescript
     * room.localParticipant?.registerRpcMethod(
     *   'greet',
     *   async (data: RpcInvocationData) => {
     *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);
     *     return `Hello, ${data.callerIdentity}!`;
     *   }
     * );
     * ```
     *
     * See {@link RpcInvocationData} for more details on invocation params.
     *
     * The handler should return a Promise that resolves to a string.
     * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.
     *
     * You may throw errors of type `RpcError` with a string `message` in the handler,
     * and they will be received on the caller's side with the message intact.
     * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` ("Application Error").
     */
    registerRpcMethod(method, handler) {
        this.rpcHandlers.set(method, handler);
        const req = create(RegisterRpcMethodRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            method,
        });
        FfiClient.instance.request({
            message: { case: 'registerRpcMethod', value: req },
        });
    }
    /**
     * Unregisters a previously registered RPC method.
     *
     * @param method - The name of the RPC method to unregister
     */
    unregisterRpcMethod(method) {
        this.rpcHandlers.delete(method);
        const req = create(UnregisterRpcMethodRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            method,
        });
        FfiClient.instance.request({
            message: { case: 'unregisterRpcMethod', value: req },
        });
    }
    /** @internal */
    async handleRpcMethodInvocation(invocationId, method, requestId, callerIdentity, payload, responseTimeout) {
        let responseError = null;
        let responsePayload = null;
        const handler = this.rpcHandlers.get(method);
        if (!handler) {
            responseError = RpcError.builtIn('UNSUPPORTED_METHOD');
        }
        else {
            try {
                responsePayload = await handler({ requestId, callerIdentity, payload, responseTimeout });
            }
            catch (error) {
                if (error instanceof RpcError) {
                    responseError = error;
                }
                else {
                    console.warn(`Uncaught error returned by RPC handler for ${method}. Returning APPLICATION_ERROR instead.`, error);
                    responseError = RpcError.builtIn('APPLICATION_ERROR');
                }
            }
        }
        const req = create(RpcMethodInvocationResponseRequestSchema, {
            localParticipantHandle: this.ffi_handle.handle,
            invocationId,
            error: responseError ? responseError.toProto() : undefined,
            payload: responsePayload ?? undefined,
        });
        const res = FfiClient.instance.request({
            message: { case: 'rpcMethodInvocationResponse', value: req },
        });
        if (res.error) {
            console.warn(`error sending rpc method invocation response: ${res.error}`);
        }
    }
}
export class RemoteParticipant extends Participant {
    constructor(owned_info) {
        super(owned_info);
        this.trackPublications = new Map();
    }
}
//# sourceMappingURL=participant.js.map