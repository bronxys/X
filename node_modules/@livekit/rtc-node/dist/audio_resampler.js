var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AudioResampler_inputRate, _AudioResampler_outputRate, _AudioResampler_channels, _AudioResampler_ffiHandle;
// SPDX-FileCopyrightText: 2024 LiveKit, Inc.
//
// SPDX-License-Identifier: Apache-2.0
import { create } from '@bufbuild/protobuf';
import { AudioFrame } from './audio_frame.js';
import { FfiClient, FfiHandle } from './ffi_client.js';
import { FlushSoxResamplerRequestSchema, NewSoxResamplerRequestSchema, PushSoxResamplerRequestSchema, SoxResamplerDataType, } from './proto/audio_frame_pb.js';
/**
 * Resampler quality. Higher quality settings result in better audio quality but require more
 * processing power.
 */
export var AudioResamplerQuality;
(function (AudioResamplerQuality) {
    AudioResamplerQuality[AudioResamplerQuality["QUICK"] = 0] = "QUICK";
    AudioResamplerQuality[AudioResamplerQuality["LOW"] = 1] = "LOW";
    AudioResamplerQuality[AudioResamplerQuality["MEDIUM"] = 2] = "MEDIUM";
    AudioResamplerQuality[AudioResamplerQuality["HIGH"] = 3] = "HIGH";
    AudioResamplerQuality[AudioResamplerQuality["VERY_HIGH"] = 4] = "VERY_HIGH";
})(AudioResamplerQuality || (AudioResamplerQuality = {}));
/**
 * AudioResampler provides functionality to resample audio data from an input sample rate to
 * an output sample rate using the Sox resampling library. It supports multiple channels and
 * configurable resampling quality.
 */
export class AudioResampler {
    /**
     * Initializes a new AudioResampler.
     *
     * @param inputRate - The sample rate of the input audio data (in Hz).
     * @param outputRate - The desired sample rate of the output audio data (in Hz).
     * @param channels - The number of audio channels (e.g., 1 for mono, 2 for stereo). Defaults to 1.
     * @param quality - The quality setting for the resampler. Defaults to
     * `AudioResamplerQuality.MEDIUM`.
     */
    constructor(inputRate, outputRate, channels = 1, quality = AudioResamplerQuality.MEDIUM) {
        _AudioResampler_inputRate.set(this, void 0);
        _AudioResampler_outputRate.set(this, void 0);
        _AudioResampler_channels.set(this, void 0);
        _AudioResampler_ffiHandle.set(this, void 0);
        __classPrivateFieldSet(this, _AudioResampler_inputRate, inputRate, "f");
        __classPrivateFieldSet(this, _AudioResampler_outputRate, outputRate, "f");
        __classPrivateFieldSet(this, _AudioResampler_channels, channels, "f");
        const req = create(NewSoxResamplerRequestSchema, {
            inputRate,
            outputRate,
            numChannels: channels,
            qualityRecipe: quality,
            inputDataType: SoxResamplerDataType.SOXR_DATATYPE_INT16I,
            outputDataType: SoxResamplerDataType.SOXR_DATATYPE_INT16I,
            flags: 0,
        });
        const res = FfiClient.instance.request({
            message: {
                case: 'newSoxResampler',
                value: req,
            },
        });
        if (res.message.case !== 'resampler') {
            throw new Error(res.message.value ?? 'Unknown Error');
        }
        __classPrivateFieldSet(this, _AudioResampler_ffiHandle, new FfiHandle(res.message.value.handle.id), "f");
    }
    /**
     * Push audio data into the resampler and retrieve any available resampled data.
     *
     * This method accepts audio data, resamples it according to the configured input and output rates,
     * and returns any resampled data that is available after processing the input.
     *
     * @param data - The audio frame to resample
     *
     * @returns A list of {@link AudioFrame} objects containing the resampled audio data. The list may
     * be empty if no output data is available yet.
     */
    push(data) {
        const req = create(PushSoxResamplerRequestSchema, {
            resamplerHandle: __classPrivateFieldGet(this, _AudioResampler_ffiHandle, "f").handle,
            dataPtr: data.protoInfo().dataPtr,
            size: data.data.byteLength,
        });
        const res = FfiClient.instance.request({
            message: {
                case: 'pushSoxResampler',
                value: req,
            },
        });
        if (res.error) {
            throw new Error(res.error);
        }
        if (!res.outputPtr) {
            return [];
        }
        const outputData = FfiClient.instance.copyBuffer(res.outputPtr, res.size);
        return [
            new AudioFrame(new Int16Array(outputData.buffer), __classPrivateFieldGet(this, _AudioResampler_outputRate, "f"), __classPrivateFieldGet(this, _AudioResampler_channels, "f"), Math.trunc(outputData.length / __classPrivateFieldGet(this, _AudioResampler_channels, "f") / 2)),
        ];
    }
    /**
     * Flush any remaining audio data through the resampler and retrieve the resampled data.
     *
     * @remarks
     * This method should be called when no more input data will be provided to ensure that all
     * internal buffers are processed and all resampled data is output.
     */
    flush() {
        const req = create(FlushSoxResamplerRequestSchema, {
            resamplerHandle: __classPrivateFieldGet(this, _AudioResampler_ffiHandle, "f").handle,
        });
        const res = FfiClient.instance.request({
            message: {
                case: 'flushSoxResampler',
                value: req,
            },
        });
        if (res.error) {
            throw new Error(res.error);
        }
        if (!res.outputPtr) {
            return [];
        }
        const outputData = FfiClient.instance.copyBuffer(res.outputPtr, res.size);
        return [
            new AudioFrame(new Int16Array(outputData.buffer), __classPrivateFieldGet(this, _AudioResampler_outputRate, "f"), __classPrivateFieldGet(this, _AudioResampler_channels, "f"), Math.trunc(outputData.length / __classPrivateFieldGet(this, _AudioResampler_channels, "f") / 2)),
        ];
    }
}
_AudioResampler_inputRate = new WeakMap(), _AudioResampler_outputRate = new WeakMap(), _AudioResampler_channels = new WeakMap(), _AudioResampler_ffiHandle = new WeakMap();
//# sourceMappingURL=audio_resampler.js.map