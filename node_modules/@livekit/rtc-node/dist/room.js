// SPDX-FileCopyrightText: 2024 LiveKit, Inc.
//
// SPDX-License-Identifier: Apache-2.0
import { create } from '@bufbuild/protobuf';
import EventEmitter from 'events';
import { E2EEManager } from './e2ee.js';
import { FfiClient, FfiClientEvent, FfiHandle } from './ffi_client.js';
import { LocalParticipant, RemoteParticipant } from './participant.js';
import { EncryptionState } from './proto/e2ee_pb.js';
import { ConnectRequestSchema, ConnectionState, ContinualGatheringPolicy, IceTransportType, } from './proto/room_pb.js';
import { TrackKind } from './proto/track_pb.js';
import { RemoteAudioTrack, RemoteVideoTrack } from './track.js';
import { RemoteTrackPublication } from './track_publication.js';
export const defaultRtcConfiguration = {
    iceTransportType: IceTransportType.TRANSPORT_ALL,
    continualGatheringPolicy: ContinualGatheringPolicy.GATHER_CONTINUALLY,
    iceServers: [],
};
export const defaultRoomOptions = {
    autoSubscribe: true,
    dynacast: false,
    e2ee: undefined,
    rtcConfig: undefined,
    adaptiveStream: false,
    joinRetries: 1,
};
export class Room extends EventEmitter {
    constructor() {
        super();
        this.connectionState = ConnectionState.CONN_DISCONNECTED;
        this.remoteParticipants = new Map();
        this.onFfiEvent = (ffiEvent) => {
            if (!this.localParticipant || !this.ffiHandle || !this.info) {
                throw TypeError('cannot handle ffi events before connectCallback');
            }
            if (ffiEvent.message.case == 'rpcMethodInvocation') {
                if (ffiEvent.message.value.localParticipantHandle == this.localParticipant.ffi_handle.handle) {
                    this.localParticipant.handleRpcMethodInvocation(ffiEvent.message.value.invocationId, ffiEvent.message.value.method, ffiEvent.message.value.requestId, ffiEvent.message.value.callerIdentity, ffiEvent.message.value.payload, ffiEvent.message.value.responseTimeoutMs);
                }
                return;
            }
            else if (ffiEvent.message.case != 'roomEvent' ||
                ffiEvent.message.value.roomHandle != this.ffiHandle.handle) {
                return;
            }
            const ev = ffiEvent.message.value.message;
            if (ev.case == 'participantConnected') {
                const participant = this.createRemoteParticipant(ev.value.info);
                this.remoteParticipants.set(participant.identity, participant);
                this.emit(RoomEvent.ParticipantConnected, participant);
            }
            else if (ev.case == 'participantDisconnected') {
                const participant = this.remoteParticipants.get(ev.value.participantIdentity);
                if (participant) {
                    this.remoteParticipants.delete(participant.identity);
                    this.emit(RoomEvent.ParticipantDisconnected, participant);
                }
            }
            else if (ev.case == 'localTrackPublished') {
                const publication = this.localParticipant.trackPublications.get(ev.value.trackSid);
                if (!publication) {
                    throw new TypeError('local track publication not found');
                }
                this.emit(RoomEvent.LocalTrackPublished, publication, this.localParticipant);
            }
            else if (ev.case == 'localTrackUnpublished') {
                const publication = this.localParticipant.trackPublications.get(ev.value.publicationSid);
                this.localParticipant.trackPublications.delete(ev.value.publicationSid);
                if (publication) {
                    this.emit(RoomEvent.LocalTrackUnpublished, publication, this.localParticipant);
                }
            }
            else if (ev.case == 'localTrackSubscribed') {
                const publication = this.localParticipant.trackPublications.get(ev.value.trackSid);
                if (!publication) {
                    throw new TypeError('local track publication not found');
                }
                publication.resolveFirstSubscription();
                this.emit(RoomEvent.LocalTrackSubscribed, publication.track);
            }
            else if (ev.case == 'trackPublished') {
                const participant = this.requireRemoteParticipant(ev.value.participantIdentity);
                const publication = new RemoteTrackPublication(ev.value.publication);
                participant.trackPublications.set(publication.sid, publication);
                this.emit(RoomEvent.TrackPublished, publication, participant);
            }
            else if (ev.case == 'trackUnpublished') {
                const participant = this.requireRemoteParticipant(ev.value.participantIdentity);
                const publication = participant.trackPublications.get(ev.value.publicationSid);
                participant.trackPublications.delete(ev.value.publicationSid);
                if (publication) {
                    this.emit(RoomEvent.TrackUnpublished, publication, participant);
                }
            }
            else if (ev.case == 'trackSubscribed') {
                const ownedTrack = ev.value.track;
                const trackInfo = ownedTrack.info;
                const { participant, publication } = this.requirePublicationOfRemoteParticipant(ev.value.participantIdentity, trackInfo.sid);
                publication.subscribed = true;
                if (trackInfo.kind == TrackKind.KIND_VIDEO) {
                    publication.track = new RemoteVideoTrack(ownedTrack);
                }
                else if (trackInfo.kind == TrackKind.KIND_AUDIO) {
                    publication.track = new RemoteAudioTrack(ownedTrack);
                }
                this.emit(RoomEvent.TrackSubscribed, publication.track, publication, participant);
            }
            else if (ev.case == 'trackUnsubscribed') {
                const { participant, publication } = this.requirePublicationOfRemoteParticipant(ev.value.participantIdentity, ev.value.trackSid);
                const track = publication.track;
                publication.track = undefined;
                publication.subscribed = false;
                this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);
            }
            else if (ev.case == 'trackSubscriptionFailed') {
                const participant = this.requireRemoteParticipant(ev.value.participantIdentity);
                this.emit(RoomEvent.TrackSubscriptionFailed, ev.value.trackSid, participant, ev.value.error);
            }
            else if (ev.case == 'trackMuted') {
                const { participant, publication } = this.requirePublicationOfParticipant(ev.value.participantIdentity, ev.value.trackSid);
                publication.info.muted = true;
                if (publication.track) {
                    publication.track.info.muted = true;
                }
                this.emit(RoomEvent.TrackMuted, publication, participant);
            }
            else if (ev.case == 'trackUnmuted') {
                const { participant, publication } = this.requirePublicationOfParticipant(ev.value.participantIdentity, ev.value.trackSid);
                publication.info.muted = false;
                if (publication.track) {
                    publication.track.info.muted = false;
                }
                this.emit(RoomEvent.TrackUnmuted, publication, participant);
            }
            else if (ev.case == 'activeSpeakersChanged') {
                const activeSpeakers = ev.value.participantIdentities.map((identity) => this.requireParticipantByIdentity(identity));
                this.emit(RoomEvent.ActiveSpeakersChanged, activeSpeakers);
            }
            else if (ev.case == 'roomMetadataChanged') {
                this.info.metadata = ev.value.metadata;
                this.emit(RoomEvent.RoomMetadataChanged, this.info.metadata);
            }
            else if (ev.case == 'participantMetadataChanged') {
                const participant = this.requireParticipantByIdentity(ev.value.participantIdentity);
                participant.info.metadata = ev.value.metadata;
                this.emit(RoomEvent.ParticipantMetadataChanged, participant.metadata, participant);
            }
            else if (ev.case == 'participantNameChanged') {
                const participant = this.requireParticipantByIdentity(ev.value.participantIdentity);
                participant.info.name = ev.value.name;
                this.emit(RoomEvent.ParticipantNameChanged, participant.name, participant);
            }
            else if (ev.case == 'participantAttributesChanged') {
                const participant = this.requireParticipantByIdentity(ev.value.participantIdentity);
                participant.info.attributes = ev.value.attributes.reduce((acc, value) => {
                    acc[value.key] = value.value;
                    return acc;
                }, {});
                if (Object.keys(ev.value.changedAttributes).length > 0) {
                    const changedAttributes = ev.value.changedAttributes.reduce((acc, value) => {
                        acc[value.key] = value.value;
                        return acc;
                    }, {});
                    this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);
                }
            }
            else if (ev.case == 'connectionQualityChanged') {
                const participant = this.requireParticipantByIdentity(ev.value.participantIdentity);
                this.emit(RoomEvent.ConnectionQualityChanged, ev.value.quality, participant);
            }
            else if (ev.case == 'chatMessage') {
                const participant = this.retrieveParticipantByIdentity(ev.value.participantIdentity);
                const { id, message: messageText, timestamp, editTimestamp, generated } = ev.value.message;
                const message = {
                    id,
                    message: messageText,
                    timestamp: Number(timestamp),
                    editTimestamp: Number(editTimestamp),
                    generated,
                };
                this.emit(RoomEvent.ChatMessage, message, participant);
            }
            else if (ev.case == 'dataPacketReceived') {
                // Can be undefined if the data is sent from a Server SDK
                const participant = this.remoteParticipants.get(ev.value.participantIdentity);
                const dataPacket = ev.value.value;
                switch (dataPacket.case) {
                    case 'user':
                        const data = dataPacket.value.data.data;
                        const buffer = FfiClient.instance.copyBuffer(data.dataPtr, Number(data.dataLen));
                        new FfiHandle(dataPacket.value.data.handle.id).dispose();
                        this.emit(RoomEvent.DataReceived, buffer, participant, ev.value.kind, dataPacket.value.topic);
                        break;
                    case 'sipDtmf':
                        const { code, digit } = dataPacket.value;
                        this.emit(RoomEvent.DtmfReceived, code, digit, participant);
                        break;
                    default:
                        break;
                }
            }
            else if (ev.case == 'e2eeStateChanged') {
                if (ev.value.state == EncryptionState.INTERNAL_ERROR) {
                    // throw generic error until Rust SDK is updated to supply the error alongside INTERNAL_ERROR
                    this.emit(RoomEvent.EncryptionError, new Error('internal server error'));
                }
            }
            else if (ev.case == 'connectionStateChanged') {
                this.connectionState = ev.value.state;
                this.emit(RoomEvent.ConnectionStateChanged, this.connectionState);
                /*} else if (ev.case == 'connected') {
                this.emit(RoomEvent.Connected);*/
            }
            else if (ev.case == 'disconnected') {
                this.emit(RoomEvent.Disconnected, ev.value.reason);
            }
            else if (ev.case == 'reconnecting') {
                this.emit(RoomEvent.Reconnecting);
            }
            else if (ev.case == 'reconnected') {
                this.emit(RoomEvent.Reconnected);
            }
            else if (ev.case == 'roomSidChanged') {
                this.emit(RoomEvent.RoomSidChanged, ev.value.sid);
            }
        };
    }
    get name() {
        return this.info?.name;
    }
    get metadata() {
        return this.info?.metadata;
    }
    get isConnected() {
        return this.ffiHandle != undefined && this.connectionState != ConnectionState.CONN_DISCONNECTED;
    }
    async getSid() {
        if (!this.isConnected) {
            return '';
        }
        if (this.info && this.info.sid !== '') {
            return this.info.sid;
        }
        return new Promise((resolve, reject) => {
            const handleRoomUpdate = (sid) => {
                if (sid !== '') {
                    this.off(RoomEvent.RoomSidChanged, handleRoomUpdate);
                    resolve(sid);
                }
            };
            this.on(RoomEvent.RoomSidChanged, handleRoomUpdate);
            this.once(RoomEvent.Disconnected, () => {
                this.off(RoomEvent.RoomSidChanged, handleRoomUpdate);
                reject('Room disconnected before room server id was available');
            });
        });
    }
    async connect(url, token, opts) {
        const options = { ...defaultRoomOptions, ...opts };
        const req = create(ConnectRequestSchema, {
            url: url,
            token: token,
            options,
        });
        const res = FfiClient.instance.request({
            message: {
                case: 'connect',
                value: req,
            },
        });
        const cb = await FfiClient.instance.waitFor((ev) => {
            return ev.message.case == 'connect' && ev.message.value.asyncId == res.asyncId;
        });
        if (cb.message.case !== 'result') {
            throw new ConnectError(cb.message.value ?? 'Unknown error');
        }
        const { room, localParticipant, participants } = cb.message.value;
        this.ffiHandle = new FfiHandle(room.handle.id);
        if (options.e2ee) {
            this.e2eeManager = new E2EEManager(this.ffiHandle.handle, options.e2ee);
        }
        this.info = room.info;
        this.connectionState = ConnectionState.CONN_CONNECTED;
        this.localParticipant = new LocalParticipant(localParticipant);
        for (const pt of participants) {
            const rp = this.createRemoteParticipant(pt.participant);
            for (const pub of pt.publications) {
                const publication = new RemoteTrackPublication(pub);
                rp.trackPublications.set(publication.sid, publication);
            }
        }
        FfiClient.instance.on(FfiClientEvent.FfiEvent, this.onFfiEvent);
    }
    async disconnect() {
        if (!this.isConnected || !this.ffiHandle) {
            return;
        }
        FfiClient.instance.request({
            message: {
                case: 'disconnect',
                value: {
                    roomHandle: this.ffiHandle.handle,
                },
            },
        });
        FfiClient.instance.removeListener(FfiClientEvent.FfiEvent, this.onFfiEvent);
        this.removeAllListeners();
    }
    retrieveParticipantByIdentity(identity) {
        if (this.localParticipant?.identity === identity) {
            return this.localParticipant;
        }
        else {
            return this.remoteParticipants.get(identity);
        }
    }
    requireParticipantByIdentity(identity) {
        if (this.localParticipant?.identity === identity) {
            return this.localParticipant;
        }
        else if (this.remoteParticipants.has(identity)) {
            return this.remoteParticipants.get(identity);
        }
        else {
            throw new TypeError(`participant ${identity} not found`);
        }
    }
    requireRemoteParticipant(identity) {
        const participant = this.remoteParticipants.get(identity);
        if (!participant) {
            throw new TypeError(`participant ${identity} not found`);
        }
        return participant;
    }
    requirePublicationOfParticipant(identity, trackSid) {
        const participant = this.requireParticipantByIdentity(identity);
        const publication = participant.trackPublications.get(trackSid);
        if (!publication) {
            throw new TypeError(`publication ${trackSid} not found`);
        }
        return { participant, publication };
    }
    requirePublicationOfRemoteParticipant(identity, trackSid) {
        const participant = this.requireRemoteParticipant(identity);
        const publication = participant.trackPublications.get(trackSid);
        if (!publication) {
            throw new TypeError(`publication ${trackSid} not found`);
        }
        return { participant, publication };
    }
    createRemoteParticipant(ownedInfo) {
        if (this.remoteParticipants.has(ownedInfo.info.identity)) {
            throw new Error('Participant already exists');
        }
        const participant = new RemoteParticipant(ownedInfo);
        this.remoteParticipants.set(ownedInfo.info.identity, participant);
        return participant;
    }
}
export class ConnectError extends Error {
    constructor(message) {
        super(message);
    }
}
export var RoomEvent;
(function (RoomEvent) {
    RoomEvent["ParticipantConnected"] = "participantConnected";
    RoomEvent["ParticipantDisconnected"] = "participantDisconnected";
    RoomEvent["LocalTrackPublished"] = "localTrackPublished";
    RoomEvent["LocalTrackUnpublished"] = "localTrackUnpublished";
    RoomEvent["LocalTrackSubscribed"] = "localTrackSubscribed";
    RoomEvent["TrackPublished"] = "trackPublished";
    RoomEvent["TrackUnpublished"] = "trackUnpublished";
    RoomEvent["TrackSubscribed"] = "trackSubscribed";
    RoomEvent["TrackUnsubscribed"] = "trackUnsubscribed";
    RoomEvent["TrackSubscriptionFailed"] = "trackSubscriptionFailed";
    RoomEvent["TrackMuted"] = "trackMuted";
    RoomEvent["TrackUnmuted"] = "trackUnmuted";
    RoomEvent["ActiveSpeakersChanged"] = "activeSpeakersChanged";
    RoomEvent["RoomMetadataChanged"] = "roomMetadataChanged";
    RoomEvent["RoomSidChanged"] = "roomSidChanged";
    RoomEvent["ParticipantMetadataChanged"] = "participantMetadataChanged";
    RoomEvent["ParticipantNameChanged"] = "participantNameChanged";
    RoomEvent["ParticipantAttributesChanged"] = "participantAttributesChanged";
    RoomEvent["ConnectionQualityChanged"] = "connectionQualityChanged";
    RoomEvent["DataReceived"] = "dataReceived";
    RoomEvent["ChatMessage"] = "chatMessage";
    RoomEvent["DtmfReceived"] = "dtmfReceived";
    RoomEvent["EncryptionError"] = "encryptionError";
    RoomEvent["ConnectionStateChanged"] = "connectionStateChanged";
    RoomEvent["Connected"] = "connected";
    RoomEvent["Disconnected"] = "disconnected";
    RoomEvent["Reconnecting"] = "reconnecting";
    RoomEvent["Reconnected"] = "reconnected";
})(RoomEvent || (RoomEvent = {}));
//# sourceMappingURL=room.js.map