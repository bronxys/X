// SPDX-FileCopyrightText: 2024 LiveKit, Inc.
//
// SPDX-License-Identifier: Apache-2.0
import { create } from '@bufbuild/protobuf';
import { Mutex } from '@livekit/mutex';
import { FfiClient, FfiClientEvent, FfiHandle } from './ffi_client.js';
import { NewVideoStreamRequestSchema, VideoStreamType } from './proto/video_frame_pb.js';
import { VideoFrame } from './video_frame.js';
export class VideoStream {
    constructor(track) {
        /** @internal */
        this.eventQueue = [];
        /** @internal */
        this.queueResolve = null;
        /** @internal */
        this.mutex = new Mutex();
        this.onEvent = (ev) => {
            if (ev.message.case != 'videoStreamEvent' ||
                ev.message.value.streamHandle != this.ffiHandle.handle) {
                return;
            }
            const streamEvent = ev.message.value.message;
            switch (streamEvent.case) {
                case 'frameReceived':
                    const rotation = streamEvent.value.rotation;
                    const timestampUs = streamEvent.value.timestampUs;
                    const frame = VideoFrame.fromOwnedInfo(streamEvent.value.buffer);
                    const value = { rotation, timestampUs, frame };
                    if (this.queueResolve) {
                        this.queueResolve({ done: false, value });
                    }
                    else {
                        this.eventQueue.push(value);
                    }
                    break;
                case 'eos':
                    FfiClient.instance.off(FfiClientEvent.FfiEvent, this.onEvent);
                    break;
            }
        };
        this.track = track;
        const req = create(NewVideoStreamRequestSchema, {
            type: VideoStreamType.VIDEO_STREAM_NATIVE,
            trackHandle: track.ffi_handle.handle,
        });
        const res = FfiClient.instance.request({
            message: {
                case: 'newVideoStream',
                value: req,
            },
        });
        this.info = res.stream.info;
        this.ffiHandle = new FfiHandle(res.stream.handle.id);
        FfiClient.instance.on(FfiClientEvent.FfiEvent, this.onEvent);
    }
    async next() {
        const unlock = await this.mutex.lock();
        if (this.eventQueue.length > 0) {
            unlock();
            const value = this.eventQueue.shift();
            if (value) {
                return { done: false, value };
            }
            else {
                return { done: true, value: undefined };
            }
        }
        const promise = new Promise((resolve) => (this.queueResolve = resolve));
        unlock();
        return promise;
    }
    close() {
        this.eventQueue.push(null);
        this.ffiHandle.dispose();
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
//# sourceMappingURL=video_stream.js.map